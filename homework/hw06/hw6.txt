1. We can trace our intended swi operation to figure out what hardware changes and control signals need to be set. Initially, rA will store regAddr and rB will store 000, which corresponds to $0 and has a constant value of 0. We set muxRF to 0 so that rA is transmitted to SRC2 and muxDST to 0 so that 000 is transmitted to SRC1. We retrieve the respective data values from our SRC register inputs and send both as inputs to the ALU. For this to happen, we set muxALU to 0. We want SRC1 to be transmitted to dataAddr, so we simply add the values of our inputs. This is done by setting FUNC_ALU to 0. In order for the immediate value to be stored in our desired memory address, we need to connect the sign-extended immediate value to dataIn in memory. We can do this by adding a multiplexer (muxDataIn) with inputs from SRCdataOut and the sign-extended immediate value. We create a new control signal for this multiplexer and designate 0 to output SRCdataOut and 1 to output the sign-extended immediate value. We set this control signal to 1. We also need to set the control signal for WE_dmem to 1 so that the value is written to memory. After completing the operation we want to increment the program counter by 1 so we set muxPC to 1.

2. The execution time (ET) of a program is equivalent to the product of the number of instructions in the program (K), the cycles per instruction (CPI), and the clock cycle time. The clock cycle time is the inverse of the clock frequency (CF). So, we have ET = (K) * (CPI) / (CF). We can compare computers A and B by keeping K constant and seeing which processor has the lower ET. We have ET_A = 4K/5 and ET_B = 2K/3. So, computer B has the lower execution time, and will run programs (4K/5 -  2K/3)/(2K/3) = 1/5 = 20% faster than computer A.

3. We use the same approach as in #1: tracing our intended instruction execution. Initially reg1 will store regAddr and reg2 will store 000, which corresponds to $0 and has a constant value of 0. 


 

