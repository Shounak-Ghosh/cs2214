1. We need a connection between the immediate value and Memory dataIn. More specifically, this can be achieved by creating a multiplexer MUX_dataIn with inputs from SRC1dataOut and the sign-extended immediate value. We create a new control signal for this multiplexer and designate 0 to output SRC1dataOut and 1 to output the sign-extended immediate value. We now trace the instruction through execution to determin the nessessary control signals. MUX_rf = 0 so rA storing regAddr is passed to SRC2 and MUX_dst = 0 so rb storing 000 is passed to SRC1. WE_rf = 0 since we are not writing to the register file. MUX_alu = 0 so SRC1dataOut is passed to the ALU. FUNC_alu = 0 so the ALU adds the values of SRC1dataOut and SRC2dataOut. MUX_dataIn = 1 so the sign-extended immediate value is passed to Memory dataIn. WE_dmem = 1 so the value is written to memory. MUX_pc = 1 so the program counter is incremented by 1. MUX_tgt = dont care since we do not modify any registers based on the memory. 

2. The execution time (ET) of a program is equivalent to the product of the number of instructions in the program (K), the cycles per instruction (CPI), and the clock cycle time. The clock cycle time is the inverse of the clock frequency (CF). So, we have ET = (K) * (CPI) / (CF). We can compare computers A and B by keeping K constant and seeing which processor has the lower ET. We have ET_A = 4K/5 and ET_B = 2K/3. So, computer B has the lower execution time, and will run programs (4K/5 -  2K/3)/(2K/3) = 1/5 = 20% faster than computer A.

3. We need a connection between Memory dataOut and the program counter. More specifically, this can be achieved by adding a wire from Memory dataOut to MUX_pc. However, we also need to expand MUXpc to be a 2-bit multiplexer so that it can take additional inputs and we designate 3 to transmit the value from Memory dataOut. We dont make any changes to the input wires to signals 0 and 1, and signal 4 is left unassigend. We now trace the instruction through the 5 stages of execution. 

Instruction fetch (IF): The execution state is 0, as with all instructions. 
Instruction decode (ID): MUX_r1 = 4, WE_a = 1 so the value in regAddr is stored, MUX_b, WE_b = dont care because the second register (000) is not used. 
Execution (EXEC): MUX_alu = 0, aluOP = 0, WE_alu = 1 so our sign-extended immediate value is added to the value in regAddr and stored in aluOut. 
Memory access (MEM): MUX_addr = 0 so we can retrive the memory value at aluOut WE_ram = 0 since we are not modifying any memory values. 
Write back (WB): MUX_pc = 3, WE_pc = 1 to transmit the value from Memory dataOut to the program counter. MUX_pcincr =  dont care since we jumping to a new address and not incrementing the program counter.